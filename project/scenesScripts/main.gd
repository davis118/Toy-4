extends Node2D





var playerScene = preload("res://scenesScripts/player.tscn")
var smallEnemyScene = preload("res://scenesScripts/smallenemy.tscn")
var laserEnemyScene = preload("res://scenesScripts/laserenemy.tscn")


var player
var playing = false

var diff = 0
var type = 0



var actionmusic
var idlemusic 
var idleplayer
var actionplayer 

var chilling = false


#saved variables!!!!!
#stats/options
var hdiff = 0
var htype = 0
var flights = 0
var music = 0
var sfx = 0

#shop stuff
var money = 0
var startinglives = 2

#uncomment following for save capabilities
func save():
	var dict = {
		"hdiff": hdiff,
		"htype": htype,
		"flights": flights,
		"music": music,
		"sfx": sfx,
		"money": money,
		"startinglives": startinglives,
		
	}
	return dict
	
func save_game():
	print("SAVING GAME")
	var save_game = FileAccess.open("user://savegame.save", FileAccess.WRITE)
		# JSON provides a static method to serialized JSON string.
	var json_string = JSON.stringify(save())
	print(save())
		# Store the save dictionary as a new line in the save file.
	save_game.store_line(json_string)

func load_game():
	if not FileAccess.file_exists("user://savegame.save"):
		return #who cares, no save
	var save_game = FileAccess.open("user://savegame.save", FileAccess.READ)
	while save_game.get_position() < save_game.get_length():
		var json_string = save_game.get_line()
		var json = JSON.new()
		var parse_result = json.parse(json_string)
		if not parse_result == OK:
			print("JSON Parse Error: ", json.get_error_message(), " in ", json_string, " at line ", json.get_error_line())
			continue
		# Get the data from the JSON object
		var data = json.get_data()

		if data.has("hdiff"):
			hdiff = data["hdiff"]
		if data.has("htype"):
			htype = data["htype"]
		if data.has("flights"):
			flights = data["flights"]
		if data.has("music"):
			music = data["music"]
		if data.has("sfx"):
			sfx = data["sfx"]
			
			#shop data
		if data.has("startinglives"):
			startinglives = data["startinglives"]
	
func spawnEnemies(): #difficulty and type of wave
	#difficulty increases number of enemies
	#type decides what arrangement/types of enemies
	#it is generated by the game, this way there are infinite levels, arcade-style
	print("spawning in: " + str(diff+1)+"-"+str(type+1))
	$"Canvas/ingamegui/MarginContainer/VBoxContainer/counter".text =  str(diff+1)+"-"+str(type+1)
	

	if type < 1:
#type 0 - first row of straight shooters, back row of angled shooters
		for i in range(diff+3):
		
			var enemy = smallEnemyScene.instantiate()
			add_child(enemy)
			enemy.spawn(Vector2(1100,(140 + i*(800/(diff+3-1)))))
			enemy.set_meta("straight", true)
		
		for i in range(diff+2):
		
			var enemy = smallEnemyScene.instantiate()
			add_child(enemy)
			enemy.spawn(Vector2(1600,(140 + i*(800/(diff+2-1)))))
			enemy.set_meta("straight", false)
	else: if type < 2:
#type 1 - straight shooters in front, lasers in back
		for i in range(diff+2):
		
			var enemy = smallEnemyScene.instantiate()
			add_child(enemy)
			enemy.spawn(Vector2(1100,(140 + i*(800/(diff+2-1)))))
			enemy.set_meta("straight", true)
		
		for i in range(diff+2):
		
			var enemy = laserEnemyScene.instantiate()
			add_child(enemy)
			enemy.spawn(Vector2(1600,(140 + i*(800/(diff+2-1)))))
	else: if type < 3:
#type 2 - straight shooter SWARM
		for i in range(diff*2+3):
		
			var enemy = smallEnemyScene.instantiate()
			add_child(enemy)
			enemy.spawn(Vector2(1100,(140 + i*(800/(diff*2+3-1)))))
			enemy.set_meta("straight", true)
		
		for i in range(diff*2+4):
		
			var enemy = smallEnemyScene.instantiate()
			add_child(enemy)
			enemy.spawn(Vector2(1600,(140 + i*(800/(diff*2+4-1)))))
			enemy.set_meta("straight", true)
	else: if type < 4:
#type 3 - laser swarm. back row does not aim
		for i in range(diff*2+2):
		
			var enemy = laserEnemyScene.instantiate()
			add_child(enemy)
			enemy.spawn(Vector2(1100,(140 + i*(800/(diff*2+2-1)))))
		
		for i in range(diff*2+3):
		
			var enemy = laserEnemyScene.instantiate()
			add_child(enemy)
			enemy.spawn(Vector2(1600,(140 + i*(800/(diff*2+3-1)))))
			enemy.goStraight()
	else: if type < 5:
#type 4 - lasers in back, aimed shooters in front
		for i in range(diff+4):
		
			var enemy = smallEnemyScene.instantiate()
			add_child(enemy)
			enemy.spawn(Vector2(1100,(140 + i*(800/(diff+4-1)))))
			enemy.set_meta("straight", false)
		
		for i in range(diff+2):
		
			var enemy = laserEnemyScene.instantiate()
			add_child(enemy)
			enemy.spawn(Vector2(1600,(140 + i*(800/(diff+2-1)))))


func startGame():
	idleplayer.play("fadeidlemusic")
	bus.emit_signal("clear")
	bus.emit_signal("livesChanged",startinglives)
	actionplayer.stop()
	actionmusic.volume_db = -3
	actionmusic.play()
	
	
	player = playerScene.instantiate()
	add_child(player)
	player.global_position = Vector2(380,540)
	player.lives = startinglives
	
	diff = 0
	type = 0
	spawnEnemies()
	playing = true
		#this was for circle spawn, but i changed to line!!
		#var theta = i * 2 * PI /amount
		#var r = 480
		#print(Vector2(r*cos(i),r*sinx(i)))
		#enemy.spawn(Vector2(r*cos(theta),r*sin(theta)),) #relative to center!!

func updateStatsBox():
		$"Canvas/helpscreen/Control/MarginContainer/VBoxContainer/HBoxContainer/stats/statsbox".text = "\ntotal flights: "+str(flights)+"\nhighest wave: " + str(hdiff+1)+"-"+str(htype+1)+"\n\n"
# Called when the node enters the scene tree for the first time.
func updatevol(typ,val):
	
	if typ == 0:
		sfx = val
	else: if typ == 1:
		music = val
	
func over():
	actionplayer.play("fadeactionmusic")
	idleplayer.stop()
	idlemusic.volume_db = 0
	idlemusic.play()
	flights += 1
	if diff * 5 + type + 1 > hdiff * 5 + htype + 1:
		hdiff = diff
		htype = type
		
	$"Canvas/gameover/Control/VBoxContainer/stats".text = "you made it to wave: " + str(diff+1)+"-"+str(type+1) +"\n highest wave: " + str(hdiff+1)+"-"+str(htype+1)
	save_game()
	updateStatsBox()
	playing = false
	
func _ready():
	get_tree().call_group("volumesliders","up")
	$globalanims.set_meta("tween",1)
	bus.connect("start", startGame)
	bus.connect("died", over)
	bus.connect("mainmenu",save_game)
	bus.connect("updatevolume",updatevol)
	actionmusic = $actionmusic
	idlemusic = $idlemusic
	idleplayer = $idlemusic/AnimationPlayer
	actionplayer = $actionmusic/AnimationPlayer
	idlemusic.play()
	load_game()
	updateStatsBox()


# Called every frame. 'delta' is the elapsed time since the previous frame.
func _process(delta):
	
	Engine.time_scale = $globalanims.get_meta("tween")
	
	#handles game finish
	if playing == true and get_tree().get_nodes_in_group("enemies").size() == 0 and chilling == false:
		chilling = true
		$chillTimer.start()
		type +=1
		if type > 4:
			diff +=1
			type = 0
		spawnEnemies()
		pass




func _on_chill_timer_timeout():
	chilling = false
	pass # Replace with function body.


func _input(event):
	if event.is_action_pressed("menu"):
		
		if playing == false:
			print("m")
			bus.emit_signal("mainmenu")
	pass

func _on_resetstats_doit():
	hdiff = 0
	htype = 0
	flights = 0
	save_game()
	updateStatsBox()
	pass # Replace with function body.

#
#func _on_bus_main_menu():
	#if playing == true:
		#over();
	#var plr = get_tree().get_first_node_in_group("player")
	#
	#
	#if plr:
		#print("a")
		#plr.queue_free()
	#pass # Replace with function body.


func idlefadedone(anim_name):
	idlemusic.stop()
	pass # Replace with function body.


func actionfadedone(anim_name):
	actionmusic.stop()
	pass # Replace with function body.


func _on_actionmusic_finished():
	actionmusic.play()
	pass # Replace with function body.


func _on_idlemusic_finished():
	idlemusic.play()
	pass # Replace with function body.
